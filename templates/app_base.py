"""
Base Application Class for NS3 GUI Socket Applications.

This class provides the foundation for custom socket-based applications
in ns-3 simulations generated by the NS3 GUI. Users extend this class
to create custom traffic generators with full control over packet content,
timing, and behavior.

The class handles:
- Socket creation and binding
- Connection setup (for TCP)
- Scheduled packet transmission
- Receive callbacks
- Clean shutdown

Usage:
    class MyApp(ApplicationBase):
        def create_payload(self) -> bytes:
            return b"Hello from my app!"
        
        def on_packet_sent(self, seq: int, payload: bytes):
            print(f"Sent packet {seq}")
"""

import ns.core as ns_core
import ns.network as ns_network
import ns.internet as ns_internet


class ApplicationBase:
    """
    Base class for custom ns-3 socket applications.
    
    This class manages the lifecycle of a socket-based application including
    socket creation, packet transmission scheduling, and cleanup.
    
    Attributes:
        config (dict): Configuration dictionary with simulation parameters
        node (ns.Node): The ns-3 node this application is installed on
        socket: The ns-3 socket (UDP or TCP)
        is_running (bool): Whether the application is currently active
        packets_sent (int): Count of packets transmitted
        packets_received (int): Count of packets received
        bytes_sent (int): Total bytes transmitted
        bytes_received (int): Total bytes received
    """
    
    def __init__(self, config: dict):
        """
        Initialize the application with configuration.
        
        Args:
            config: Dictionary containing:
                - node: ns.Node object to install app on
                - target_address: Destination IP address (str)
                - target_port: Destination port number (int)
                - protocol: "UDP" or "TCP"
                - start_time: Simulation start time in seconds (float)
                - stop_time: Simulation stop time in seconds (float)
                - send_interval: Time between packets in seconds (float)
                - packet_size: Default packet size in bytes (int)
                - app_name: Name identifier for this application (str)
                - source_node_name: Name of source node (str)
                - target_node_name: Name of target node (str)
        """
        self.config = config
        self.node = config.get('node')
        self.target_address = config.get('target_address', '10.1.1.2')
        self.target_port = config.get('target_port', 9000)
        self.protocol = config.get('protocol', 'UDP').upper()
        self.start_time = config.get('start_time', 1.0)
        self.stop_time = config.get('stop_time', 10.0)
        self.send_interval = config.get('send_interval', 1.0)
        self.packet_size = config.get('packet_size', 512)
        self.app_name = config.get('app_name', 'CustomApp')
        self.source_node_name = config.get('source_node_name', 'Source')
        self.target_node_name = config.get('target_node_name', 'Target')
        
        # Runtime state
        self.socket = None
        self.is_running = False
        self.packets_sent = 0
        self.packets_received = 0
        self.bytes_sent = 0
        self.bytes_received = 0
        
        # Internal state
        self._send_event = None
        self._is_connected = False  # For TCP
    
    # =========================================================================
    # LIFECYCLE METHODS - Called by the simulation framework
    # =========================================================================
    
    def setup(self):
        """
        Set up the application socket and schedule start.
        
        This is called during simulation setup to create the socket
        and schedule the application to start at the configured time.
        """
        self._create_socket()
        
        # Schedule application start
        ns_core.Simulator.Schedule(
            ns_core.Seconds(self.start_time),
            self._start_application
        )
        
        # Schedule application stop
        ns_core.Simulator.Schedule(
            ns_core.Seconds(self.stop_time),
            self._stop_application
        )
        
        # Call user initialization hook
        self.on_setup()
    
    def _create_socket(self):
        """Create the appropriate socket type."""
        if self.protocol == 'TCP':
            tid = ns_internet.TcpSocketFactory.GetTypeId()
        else:
            tid = ns_internet.UdpSocketFactory.GetTypeId()
        
        self.socket = ns_network.Socket.CreateSocket(self.node, tid)
        
        # Set up receive callback
        self.socket.SetRecvCallback(self._on_socket_recv)
        
        if self.protocol == 'TCP':
            # Set up TCP-specific callbacks
            self.socket.SetConnectCallback(
                self._on_connection_succeeded,
                self._on_connection_failed
            )
            self.socket.SetCloseCallbacks(
                self._on_normal_close,
                self._on_error_close
            )
    
    def _start_application(self):
        """Start the application - called at start_time."""
        if self.is_running:
            return
        
        self.is_running = True
        
        # Set up remote address
        remote = ns_network.InetSocketAddress(
            ns_network.Ipv4Address(self.target_address),
            self.target_port
        )
        
        if self.protocol == 'TCP':
            # TCP: Initiate connection
            self.socket.Connect(remote)
        else:
            # UDP: Just connect (sets default destination)
            self.socket.Connect(remote)
            self._is_connected = True
            
            # Call user start hook
            self.on_start()
            
            # Start sending
            self._schedule_send()
    
    def _stop_application(self):
        """Stop the application - called at stop_time."""
        self.is_running = False
        
        # Cancel pending send
        if self._send_event and self._send_event.IsRunning():
            ns_core.Simulator.Cancel(self._send_event)
            self._send_event = None
        
        # Close socket
        if self.socket:
            self.socket.Close()
        
        # Call user stop hook
        self.on_stop()
    
    # =========================================================================
    # SENDING METHODS
    # =========================================================================
    
    def _schedule_send(self):
        """Schedule the next packet transmission."""
        if not self.is_running:
            return
        
        current_time = ns_core.Simulator.Now().GetSeconds()
        if current_time >= self.stop_time:
            return
        
        # Send immediately, then schedule next
        self._do_send()
        
        # Schedule next send
        self._send_event = ns_core.Simulator.Schedule(
            ns_core.Seconds(self.send_interval),
            self._schedule_send
        )
    
    def _do_send(self):
        """Perform actual packet send."""
        if not self.is_running or not self._is_connected:
            return
        
        # Get payload from user implementation
        payload = self.create_payload()
        
        if payload is None:
            return
        
        # Ensure payload is bytes
        if isinstance(payload, str):
            payload = payload.encode('utf-8')
        
        # Create and send packet
        packet = ns_network.Packet(payload, len(payload))
        bytes_sent = self.socket.Send(packet)
        
        if bytes_sent > 0:
            self.packets_sent += 1
            self.bytes_sent += bytes_sent
            
            # Call user callback
            self.on_packet_sent(self.packets_sent, payload)
    
    def send_now(self, payload: bytes = None):
        """
        Send a packet immediately (outside normal schedule).
        
        Args:
            payload: Bytes to send. If None, calls create_payload().
        
        Returns:
            int: Number of bytes sent, or -1 on error
        """
        if not self.is_running or not self._is_connected:
            return -1
        
        if payload is None:
            payload = self.create_payload()
        
        if isinstance(payload, str):
            payload = payload.encode('utf-8')
        
        packet = ns_network.Packet(payload, len(payload))
        bytes_sent = self.socket.Send(packet)
        
        if bytes_sent > 0:
            self.packets_sent += 1
            self.bytes_sent += bytes_sent
            self.on_packet_sent(self.packets_sent, payload)
        
        return bytes_sent
    
    # =========================================================================
    # SOCKET CALLBACKS
    # =========================================================================
    
    def _on_socket_recv(self, socket):
        """Handle incoming data on socket."""
        while True:
            packet = socket.Recv()
            if not packet or packet.GetSize() == 0:
                break
            
            size = packet.GetSize()
            self.packets_received += 1
            self.bytes_received += size
            
            # Extract payload data
            buffer = bytearray(size)
            packet.CopyData(buffer, size)
            
            # Call user callback
            self.on_packet_received(self.packets_received, bytes(buffer))
    
    def _on_connection_succeeded(self, socket):
        """TCP connection established."""
        self._is_connected = True
        self.on_connected()
        self.on_start()
        self._schedule_send()
    
    def _on_connection_failed(self, socket):
        """TCP connection failed."""
        self._is_connected = False
        self.on_connection_failed()
    
    def _on_normal_close(self, socket):
        """Socket closed normally."""
        self._is_connected = False
        self.on_disconnected()
    
    def _on_error_close(self, socket):
        """Socket closed due to error."""
        self._is_connected = False
        self.on_error()
    
    # =========================================================================
    # USER-OVERRIDABLE METHODS - Extend these in your application
    # =========================================================================
    
    def on_setup(self):
        """
        Called during application setup, before simulation starts.
        
        Override this to perform one-time initialization such as:
        - Loading data files
        - Initializing state variables
        - Setting up data structures
        """
        pass
    
    def on_start(self):
        """
        Called when the application starts sending.
        
        For UDP: Called immediately at start_time
        For TCP: Called after connection is established
        
        Override this to perform actions at application start.
        """
        pass
    
    def on_stop(self):
        """
        Called when the application stops.
        
        Override this to perform cleanup or final statistics logging.
        """
        pass
    
    def create_payload(self) -> bytes:
        """
        Create the payload for the next packet.
        
        OVERRIDE THIS METHOD to generate custom packet content.
        
        Returns:
            bytes: The payload data to send
            
        Example:
            def create_payload(self) -> bytes:
                # Send JSON data
                import json
                data = {
                    "seq": self.packets_sent,
                    "timestamp": Simulator.Now().GetSeconds(),
                    "message": "Hello!"
                }
                return json.dumps(data).encode()
        """
        # Default: simple sequence number payload
        msg = f"Packet {self.packets_sent} from {self.app_name}"
        return msg.encode('utf-8')
    
    def on_packet_sent(self, sequence: int, payload: bytes):
        """
        Called after each packet is sent.
        
        Override this to log or react to sent packets.
        
        Args:
            sequence: Packet sequence number (1-indexed)
            payload: The payload that was sent
        """
        pass
    
    def on_packet_received(self, sequence: int, payload: bytes):
        """
        Called when a packet is received.
        
        Override this for bidirectional applications.
        
        Args:
            sequence: Receive sequence number (1-indexed)
            payload: The received data
        """
        pass
    
    def on_connected(self):
        """
        Called when TCP connection is established.
        
        Override for TCP applications that need connection notification.
        """
        pass
    
    def on_disconnected(self):
        """
        Called when connection is closed normally.
        """
        pass
    
    def on_connection_failed(self):
        """
        Called when TCP connection attempt fails.
        """
        pass
    
    def on_error(self):
        """
        Called when socket error occurs.
        """
        pass
    
    # =========================================================================
    # UTILITY METHODS
    # =========================================================================
    
    def get_current_time(self) -> float:
        """Get current simulation time in seconds."""
        return ns_core.Simulator.Now().GetSeconds()
    
    def get_stats(self) -> dict:
        """
        Get application statistics.
        
        Returns:
            dict: Statistics including packets/bytes sent/received
        """
        return {
            'app_name': self.app_name,
            'packets_sent': self.packets_sent,
            'packets_received': self.packets_received,
            'bytes_sent': self.bytes_sent,
            'bytes_received': self.bytes_received,
            'is_running': self.is_running,
            'is_connected': self._is_connected,
        }
    
    def log(self, message: str):
        """
        Log a message with timestamp and app name.
        
        Args:
            message: Message to log
        """
        time = self.get_current_time()
        print(f"[{time:.3f}s] [{self.app_name}] {message}")


# =============================================================================
# EXAMPLE: Simple Echo Client
# =============================================================================

class EchoClientApp(ApplicationBase):
    """Example application that sends numbered messages."""
    
    def on_start(self):
        self.log("Starting echo client")
    
    def on_stop(self):
        stats = self.get_stats()
        self.log(f"Stopped. Sent {stats['packets_sent']} packets, "
                 f"{stats['bytes_sent']} bytes")
    
    def create_payload(self) -> bytes:
        msg = f"ECHO REQUEST #{self.packets_sent + 1}"
        return msg.encode('utf-8')
    
    def on_packet_sent(self, seq: int, payload: bytes):
        self.log(f"Sent: {payload.decode()}")
    
    def on_packet_received(self, seq: int, payload: bytes):
        self.log(f"Received: {payload.decode()}")


# =============================================================================
# EXAMPLE: Sensor Data Generator
# =============================================================================

class SensorDataApp(ApplicationBase):
    """Example application that sends simulated sensor data."""
    
    def on_setup(self):
        import random
        self.random = random
        self.sensor_id = self.config.get('sensor_id', 1)
        self.temperature = 20.0  # Starting temperature
    
    def create_payload(self) -> bytes:
        import json
        
        # Simulate temperature with random walk
        self.temperature += self.random.uniform(-0.5, 0.5)
        
        data = {
            'sensor_id': self.sensor_id,
            'timestamp': self.get_current_time(),
            'temperature': round(self.temperature, 2),
            'humidity': round(self.random.uniform(40, 60), 1),
            'seq': self.packets_sent + 1
        }
        
        return json.dumps(data).encode('utf-8')
    
    def on_packet_sent(self, seq: int, payload: bytes):
        self.log(f"Sensor data sent: {payload.decode()}")
