"""
NS-3 Python script generator.

Generates ns-3 Python scripts from NetworkModel and SimulationConfig.
"""

from datetime import datetime
from typing import Optional
from models import (
    NetworkModel, NodeModel, LinkModel, NodeType, ChannelType,
    SimulationConfig, TrafficFlow, TrafficApplication, TrafficProtocol
)


class NS3ScriptGenerator:
    """
    Generates ns-3 Python scripts from network topology and simulation config.
    
    The generated scripts use ns-3's Python bindings and can be run with:
        ./ns3 run scratch/generated_script.py
    """
    
    def __init__(self):
        self._node_index_map: dict[str, int] = {}
        self._link_index_map: dict[str, int] = {}
    
    def generate(
        self, 
        network: NetworkModel, 
        sim_config: SimulationConfig,
        output_dir: str = "."
    ) -> str:
        """
        Generate complete ns-3 Python script.
        
        Args:
            network: The network topology model
            sim_config: Simulation configuration with flows
            output_dir: Directory for output files (traces, pcap)
            
        Returns:
            Complete Python script as string
        """
        # Build node index mapping (node_id -> integer index)
        self._node_index_map = {
            node_id: idx 
            for idx, node_id in enumerate(network.nodes.keys())
        }
        
        sections = [
            self._generate_header(network, sim_config),
            self._generate_imports(),
            self._generate_main_function_start(),
            self._generate_nodes(network),
            self._generate_channels(network),
            self._generate_internet_stack(network),
            self._generate_ip_addresses(network),
            self._generate_applications(network, sim_config),
            self._generate_tracing(sim_config, output_dir),
            self._generate_simulation_run(sim_config, output_dir),
            self._generate_main_function_end(),
            self._generate_main_call(),
        ]
        
        return "\n".join(sections)
    
    def _generate_header(self, network: NetworkModel, sim_config: SimulationConfig) -> str:
        """Generate script header with metadata."""
        return f'''#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
NS-3 Simulation Script
Generated by ns3-gui on {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}

Topology:
  - Nodes: {len(network.nodes)}
  - Links: {len(network.links)}
  - Traffic Flows: {len(sim_config.flows)}
  
Simulation Duration: {sim_config.duration} seconds
"""
'''
    
    def _generate_imports(self) -> str:
        """Generate ns-3 import statements."""
        return '''
# NS-3 imports (ns-3.45+ with cppyy bindings)
from ns import ns

import sys
'''
    
    def _generate_main_function_start(self) -> str:
        """Generate main function start."""
        return '''
def main():
    """Run the simulation."""
    
    # Enable logging for debugging (optional)
    # ns.LogComponentEnable("UdpEchoClientApplication", ns.LOG_LEVEL_INFO)
    # ns.LogComponentEnable("UdpEchoServerApplication", ns.LOG_LEVEL_INFO)
'''
    
    def _generate_nodes(self, network: NetworkModel) -> str:
        """Generate node creation code."""
        lines = [
            "    # ============================================",
            "    # Create Nodes",
            "    # ============================================",
            f"    nodes = ns.NodeContainer()",
            f"    nodes.Create({len(network.nodes)})",
            "",
            "    # Node mapping:",
        ]
        
        for node_id, idx in self._node_index_map.items():
            node = network.nodes[node_id]
            lines.append(f"    # Node {idx}: {node.name} ({node.node_type.name})")
        
        lines.append("")
        return "\n".join(lines)
    
    def _generate_channels(self, network: NetworkModel) -> str:
        """Generate channel/link configuration."""
        lines = [
            "    # ============================================",
            "    # Create Links/Channels",
            "    # ============================================",
            "    ",
            "    # Point-to-point helper for direct links",
            "    p2p = ns.PointToPointHelper()",
            "",
            "    # CSMA helper for shared medium (switch/hub)",
            "    csma = ns.CsmaHelper()",
            "",
            "    # Store all NetDeviceContainers",
            "    all_devices = []",
            "",
        ]
        
        for idx, (link_id, link) in enumerate(network.links.items()):
            source_idx = self._node_index_map.get(link.source_node_id, 0)
            target_idx = self._node_index_map.get(link.target_node_id, 0)
            
            source_node = network.nodes.get(link.source_node_id)
            target_node = network.nodes.get(link.target_node_id)
            
            source_name = source_node.name if source_node else "unknown"
            target_name = target_node.name if target_node else "unknown"
            
            lines.append(f"    # Link {idx}: {source_name} <-> {target_name}")
            
            if link.channel_type == ChannelType.POINT_TO_POINT:
                lines.extend([
                    f"    p2p.SetDeviceAttribute('DataRate', ns.StringValue('{link.data_rate}'))",
                    f"    p2p.SetChannelAttribute('Delay', ns.StringValue('{link.delay}'))",
                    f"    link{idx}_nodes = ns.NodeContainer()",
                    f"    link{idx}_nodes.Add(nodes.Get({source_idx}))",
                    f"    link{idx}_nodes.Add(nodes.Get({target_idx}))",
                    f"    devices{idx} = p2p.Install(link{idx}_nodes)",
                    f"    all_devices.append(devices{idx})",
                    "",
                ])
            else:  # CSMA
                lines.extend([
                    f"    csma.SetChannelAttribute('DataRate', ns.StringValue('{link.data_rate}'))",
                    f"    csma.SetChannelAttribute('Delay', ns.StringValue('{link.delay}'))",
                    f"    link{idx}_nodes = ns.NodeContainer()",
                    f"    link{idx}_nodes.Add(nodes.Get({source_idx}))",
                    f"    link{idx}_nodes.Add(nodes.Get({target_idx}))",
                    f"    devices{idx} = csma.Install(link{idx}_nodes)",
                    f"    all_devices.append(devices{idx})",
                    "",
                ])
        
        return "\n".join(lines)
    
    def _generate_internet_stack(self, network: NetworkModel) -> str:
        """Generate IP stack installation."""
        lines = [
            "    # ============================================",
            "    # Install Internet Stack",
            "    # ============================================",
            "    internet_stack = ns.InternetStackHelper()",
            "    internet_stack.Install(nodes)",
            "",
        ]
        return "\n".join(lines)
    
    def _generate_ip_addresses(self, network: NetworkModel) -> str:
        """Generate IP address assignment."""
        lines = [
            "    # ============================================",
            "    # Assign IP Addresses",
            "    # ============================================",
            "    ipv4 = ns.Ipv4AddressHelper()",
            "",
            "    # Store interfaces for later use",
            "    all_interfaces = []",
            "",
        ]
        
        for idx, (link_id, link) in enumerate(network.links.items()):
            # Use subnet based on link index
            subnet = f"10.1.{idx + 1}.0"
            lines.extend([
                f"    ipv4.SetBase(ns.Ipv4Address('{subnet}'), ns.Ipv4Mask('255.255.255.0'))",
                f"    interfaces{idx} = ipv4.Assign(devices{idx})",
                f"    all_interfaces.append(interfaces{idx})",
                "",
            ])
        
        # Print IP addresses for reference
        lines.extend([
            "    # Print assigned IP addresses",
            "    print('\\nIP Address Assignment:')",
        ])
        
        for idx, (link_id, link) in enumerate(network.links.items()):
            source_node = network.nodes.get(link.source_node_id)
            target_node = network.nodes.get(link.target_node_id)
            source_name = source_node.name if source_node else "unknown"
            target_name = target_node.name if target_node else "unknown"
            
            lines.extend([
                f"    print(f'  Link {idx}: {{interfaces{idx}.GetAddress(0)}} ({source_name}) <-> {{interfaces{idx}.GetAddress(1)}} ({target_name})')",
            ])
        
        lines.append("    print()")
        lines.append("")
        return "\n".join(lines)
    
    def _generate_applications(self, network: NetworkModel, sim_config: SimulationConfig) -> str:
        """Generate traffic applications."""
        lines = [
            "    # ============================================",
            "    # Create Applications (Traffic Generators)",
            "    # ============================================",
            "",
        ]
        
        if not sim_config.flows:
            lines.extend([
                "    # No traffic flows configured",
                "    # Add flows in the GUI to generate traffic",
                "",
            ])
            return "\n".join(lines)
        
        for flow_idx, flow in enumerate(sim_config.flows):
            source_idx = self._node_index_map.get(flow.source_node_id)
            target_idx = self._node_index_map.get(flow.target_node_id)
            
            if source_idx is None or target_idx is None:
                lines.append(f"    # Flow {flow_idx}: SKIPPED - invalid node reference")
                continue
            
            source_node = network.nodes.get(flow.source_node_id)
            target_node = network.nodes.get(flow.target_node_id)
            source_name = source_node.name if source_node else "unknown"
            target_name = target_node.name if target_node else "unknown"
            
            lines.append(f"    # Flow {flow_idx}: {flow.name} ({source_name} -> {target_name})")
            
            if flow.application == TrafficApplication.ECHO:
                lines.extend(self._generate_echo_application(
                    flow_idx, flow, source_idx, target_idx, network
                ))
            else:
                # Stub for other application types
                lines.extend([
                    f"    # TODO: {flow.application.value} application not yet implemented",
                    f"    # Supported types: echo",
                    f"    # Future: onoff, bulk, ping",
                    "",
                ])
        
        return "\n".join(lines)
    
    def _generate_echo_application(
        self, 
        flow_idx: int, 
        flow: TrafficFlow, 
        source_idx: int, 
        target_idx: int,
        network: NetworkModel
    ) -> list[str]:
        """Generate UDP Echo client/server application."""
        # Find the interface address for the target node
        # We need to find which link connects to the target
        target_link_idx = None
        target_is_first = True
        
        for idx, (link_id, link) in enumerate(network.links.items()):
            if link.target_node_id == flow.target_node_id:
                target_link_idx = idx
                target_is_first = False
                break
            elif link.source_node_id == flow.target_node_id:
                target_link_idx = idx
                target_is_first = True
                break
        
        if target_link_idx is None:
            return [f"    # Flow {flow_idx}: Cannot find interface for target node", ""]
        
        port = 9000 + flow_idx
        interface_idx = 0 if target_is_first else 1
        
        lines = [
            f"    # UDP Echo Server on node {target_idx}",
            f"    echo_server{flow_idx} = ns.UdpEchoServerHelper({port})",
            f"    server_apps{flow_idx} = echo_server{flow_idx}.Install(nodes.Get({target_idx}))",
            f"    server_apps{flow_idx}.Start(ns.Seconds({flow.start_time - 0.5}))",
            f"    server_apps{flow_idx}.Stop(ns.Seconds({flow.stop_time + 0.5}))",
            "",
            f"    # UDP Echo Client on node {source_idx}",
            f"    echo_client{flow_idx} = ns.UdpEchoClientHelper(",
            f"        interfaces{target_link_idx}.GetAddress({interface_idx}), {port})",
            f"    echo_client{flow_idx}.SetAttribute('MaxPackets', ns.UintegerValue({flow.echo_packets}))",
            f"    echo_client{flow_idx}.SetAttribute('Interval', ns.TimeValue(ns.Seconds({flow.echo_interval})))",
            f"    echo_client{flow_idx}.SetAttribute('PacketSize', ns.UintegerValue({flow.packet_size}))",
            f"    client_apps{flow_idx} = echo_client{flow_idx}.Install(nodes.Get({source_idx}))",
            f"    client_apps{flow_idx}.Start(ns.Seconds({flow.start_time}))",
            f"    client_apps{flow_idx}.Stop(ns.Seconds({flow.stop_time}))",
            "",
            "    # ----------------------------------------",
            "    # Alternative traffic generators (commented out):",
            "    # ----------------------------------------",
            "    # OnOff Application (constant bitrate with on/off periods):",
            "    # onoff = ns.OnOffHelper('ns3::UdpSocketFactory',",
            "    #     ns.InetSocketAddress(target_addr, port))",
            "    # onoff.SetAttribute('DataRate', ns.StringValue('1Mbps'))",
            "    # onoff.SetAttribute('PacketSize', ns.UintegerValue(1024))",
            "    #",
            "    # Bulk Send Application (TCP bulk transfer):",
            "    # bulk = ns.BulkSendHelper('ns3::TcpSocketFactory',",
            "    #     ns.InetSocketAddress(target_addr, port))",
            "    # bulk.SetAttribute('MaxBytes', ns.UintegerValue(0))  # unlimited",
            "    #",
            "    # Packet Sink (receiver for OnOff/BulkSend):",
            "    # sink = ns.PacketSinkHelper('ns3::UdpSocketFactory',",
            "    #     ns.InetSocketAddress(ns.Ipv4Address.GetAny(), port))",
            "    # ----------------------------------------",
            "",
        ]
        return lines
    
    def _generate_tracing(self, sim_config: SimulationConfig, output_dir: str) -> str:
        """Generate tracing/logging code."""
        lines = [
            "    # ============================================",
            "    # Setup Tracing and Monitoring",
            "    # ============================================",
            "",
            "    # Packet trace callback for GUI visualization",
            "    packet_uid_counter = [0]  # Use list for mutable closure",
            "    ",
            "    def trace_tx(context, packet):",
            "        # Parse context to get node and device",
            "        # Context format: /NodeList/n/DeviceList/d/...",
            "        try:",
            "            parts = context.split('/')",
            "            node_idx = int(parts[2]) if len(parts) > 2 else 0",
            "            dev_idx = int(parts[4]) if len(parts) > 4 else 0",
            "            time_ns = ns.Simulator.Now().GetNanoSeconds()",
            "            size = packet.GetSize()",
            "            uid = packet_uid_counter[0]",
            "            packet_uid_counter[0] += 1",
            "            # Format: PKT|time_ns|event|node|device|size|src_node|dst_node|link_id|protocol",
            "            print(f'PKT|{time_ns}|TX|{node_idx}|{dev_idx}|{size}|-1|-1||UDP')",
            "        except:",
            "            pass",
            "    ",
            "    def trace_rx(context, packet):",
            "        try:",
            "            parts = context.split('/')",
            "            node_idx = int(parts[2]) if len(parts) > 2 else 0",
            "            dev_idx = int(parts[4]) if len(parts) > 4 else 0",
            "            time_ns = ns.Simulator.Now().GetNanoSeconds()",
            "            size = packet.GetSize()",
            "            print(f'PKT|{time_ns}|RX|{node_idx}|{dev_idx}|{size}|-1|-1||UDP')",
            "        except:",
            "            pass",
            "    ",
            "    def trace_drop(context, packet):",
            "        try:",
            "            parts = context.split('/')",
            "            node_idx = int(parts[2]) if len(parts) > 2 else 0",
            "            dev_idx = int(parts[4]) if len(parts) > 4 else 0",
            "            time_ns = ns.Simulator.Now().GetNanoSeconds()",
            "            size = packet.GetSize()",
            "            print(f'PKT|{time_ns}|DROP|{node_idx}|{dev_idx}|{size}|-1|-1||')",
            "        except:",
            "            pass",
            "    ",
            "    # Connect trace callbacks",
            "    # Note: In ns-3 Python bindings, we use Config.Connect or device-specific callbacks",
            "    # For now, we'll use the MacTx and MacRx callbacks if available",
            "    try:",
            "        ns.Config.ConnectWithoutContext(",
            "            '/NodeList/*/DeviceList/*/$ns3::PointToPointNetDevice/MacTx',",
            "            ns.MakeCallback(trace_tx))",
            "        ns.Config.ConnectWithoutContext(",
            "            '/NodeList/*/DeviceList/*/$ns3::PointToPointNetDevice/MacRx',",
            "            ns.MakeCallback(trace_rx))",
            "    except Exception as e:",
            "        print(f'Note: Could not connect packet trace callbacks: {e}')",
            "",
        ]
        
        if sim_config.enable_ascii_trace:
            lines.extend([
                "    # ASCII Trace",
                f"    ascii_trace = ns.AsciiTraceHelper()",
                f"    p2p.EnableAsciiAll(ascii_trace.CreateFileStream('{output_dir}/trace.tr'))",
                "",
            ])
        
        if sim_config.enable_pcap:
            lines.extend([
                "    # PCAP Trace (packet capture)",
                f"    p2p.EnablePcapAll('{output_dir}/capture')",
                "",
            ])
        
        if sim_config.enable_flow_monitor:
            lines.extend([
                "    # Flow Monitor for statistics",
                "    flow_helper = ns.FlowMonitorHelper()",
                "    flow_monitor = flow_helper.InstallAll()",
                "",
            ])
        
        return "\n".join(lines)
    
    def _generate_simulation_run(self, sim_config: SimulationConfig, output_dir: str) -> str:
        """Generate simulation run code."""
        lines = [
            "    # ============================================",
            "    # Run Simulation",
            "    # ============================================",
            f"    ns.Simulator.Stop(ns.Seconds({sim_config.duration}))",
            "",
            f"    print('Starting simulation for {sim_config.duration} seconds...')",
            "    print()",
            "",
            "    ns.Simulator.Run()",
            "",
        ]
        
        if sim_config.enable_flow_monitor:
            lines.extend([
                "    # ============================================",
                "    # Collect and Print Statistics",
                "    # ============================================",
                "    print('\\n' + '='*60)",
                "    print('SIMULATION RESULTS')",
                "    print('='*60)",
                "",
                "    flow_monitor.CheckForLostPackets()",
                "    classifier = flow_helper.GetClassifier()",
                "    stats = flow_monitor.GetFlowStats()",
                "",
                "    print(f'\\nFlow Statistics:')",
                "    print('-'*60)",
                "",
                "    for flow_id, flow_stats in stats:",
                "        # Get flow classifier info",
                "        t = classifier.FindFlow(flow_id)",
                "        ",
                "        proto = 'UDP' if t.protocol == 17 else 'TCP' if t.protocol == 6 else f'Proto-{t.protocol}'",
                "        ",
                "        print(f'Flow {flow_id} ({proto})')",
                "        print(f'  {t.sourceAddress}:{t.sourcePort} -> {t.destinationAddress}:{t.destinationPort}')",
                "        print(f'  Tx Packets: {flow_stats.txPackets}')",
                "        print(f'  Rx Packets: {flow_stats.rxPackets}')",
                "        print(f'  Tx Bytes:   {flow_stats.txBytes}')",
                "        print(f'  Rx Bytes:   {flow_stats.rxBytes}')",
                "        ",
                "        if flow_stats.rxPackets > 0:",
                "            # Calculate throughput",
                "            duration = (flow_stats.timeLastRxPacket.GetSeconds() - ",
                "                       flow_stats.timeFirstTxPacket.GetSeconds())",
                "            if duration > 0:",
                "                throughput = (flow_stats.rxBytes * 8) / duration / 1e6",
                "                print(f'  Throughput: {throughput:.2f} Mbps')",
                "            ",
                "            # Calculate delay",
                "            delay = flow_stats.delaySum.GetSeconds() / flow_stats.rxPackets * 1000",
                "            print(f'  Mean Delay: {delay:.2f} ms')",
                "            ",
                "            # Calculate jitter",
                "            if flow_stats.rxPackets > 1:",
                "                jitter = flow_stats.jitterSum.GetSeconds() / (flow_stats.rxPackets - 1) * 1000",
                "                print(f'  Mean Jitter: {jitter:.2f} ms')",
                "        ",
                "        lost = flow_stats.txPackets - flow_stats.rxPackets",
                "        if flow_stats.txPackets > 0:",
                "            loss_pct = (lost / flow_stats.txPackets) * 100",
                "            print(f'  Lost Packets: {lost} ({loss_pct:.1f}%)')",
                "        print()",
                "",
                "    # Save flow monitor results to XML",
                f"    flow_monitor.SerializeToXmlFile('{output_dir}/flowmon-results.xml', True, True)",
                f"    print('Flow monitor results saved to: {output_dir}/flowmon-results.xml')",
                "",
            ])
        
        lines.extend([
            "    ns.Simulator.Destroy()",
            "    print('\\nSimulation completed successfully.')",
            "",
        ])
        
        return "\n".join(lines)
    
    def _generate_main_function_end(self) -> str:
        """Generate main function end."""
        return '''
    return 0
'''
    
    def _generate_main_call(self) -> str:
        """Generate main function call."""
        return '''
if __name__ == '__main__':
    sys.exit(main())
'''


def generate_ns3_script(
    network: NetworkModel, 
    sim_config: SimulationConfig,
    output_dir: str = "."
) -> str:
    """
    Convenience function to generate an ns-3 script.
    
    Args:
        network: Network topology model
        sim_config: Simulation configuration
        output_dir: Output directory for trace files
        
    Returns:
        Generated Python script as string
    """
    generator = NS3ScriptGenerator()
    return generator.generate(network, sim_config, output_dir)
